import pandas as pd
import os
import gate_api
from gate_api.exceptions import ApiException
import logging
import requests

# æ—¥å¿—ç­‰çº§è®¾ç½®
LOGLEVEL = os.getenv("LOGLEVEL", "INFO").upper()  # é»˜è®¤INFOï¼Œå¼€å‘æ—¶å¯è®¾ä¸ºDEBUG
logging.basicConfig(
    format='%(asctime)s %(levelname)s: %(message)s',
    level=getattr(logging, LOGLEVEL, logging.INFO)
)
logger = logging.getLogger(__name__)

# Configure Gate.io Futures API client
api_key = os.getenv("API_KEY")  # Read-only API Key
api_secret = os.getenv("API_SECRET")  # Read-only API Secret

# Set up Futures API client
configuration = gate_api.Configuration(
    host="https://api.gateio.ws/api/v4",
    key=api_key,
    secret=api_secret
)

api_client = gate_api.ApiClient(configuration)

# Function to fetch ETH/USDT perpetual contract data
# æ›´æ–° get_market_data å‡½æ•°ï¼Œç¡®ä¿æ—¶é—´èŒƒå›´è¦†ç›–è¶³å¤Ÿçš„æ•°æ®ç‚¹

def get_market_data(timeframe='5m'):
    api_instance = gate_api.FuturesApi(api_client)
    settle = 'usdt'  # Settle currency
    contract = 'ETH_USDT'  # Trading pair (can be changed as needed)
    limit = 500  # Fetch the latest 500 candlestick data
    try:
        # Validate the contract name by fetching available contracts
        contracts = api_instance.list_futures_contracts(settle=settle)
        if contract not in [c.name for c in contracts]:
            logger.error("Contract '%s' not found. Please check the contract name.", contract)
            return None

        # Get futures candlesticks with proper parameters
        import time
        current_time = int(time.time())  # Current time in Unix timestamp

        # åŠ¨æ€è°ƒæ•´æ—¶é—´èŒƒå›´ä»¥æ»¡è¶³æ•°æ®ç‚¹éœ€æ±‚
        if timeframe == '1h':
            interval_seconds = 60 * 60  # 1 hour in seconds
            required_points = 100
        elif timeframe == '15m':
            interval_seconds = 15 * 60  # 15 minutes in seconds
            required_points = 150
        elif timeframe == '5m':
            interval_seconds = 5 * 60  # 5 minutes in seconds
            required_points = 200
        else:
            raise ValueError(f"Unsupported timeframe: {timeframe}")

        from_timestamp = current_time - (interval_seconds * required_points)
        to_timestamp = current_time

        # Fetch candlestick data with the correct parameters
        api_response = api_instance.list_futures_candlesticks(
            settle=settle,
            contract=contract,
            _from=from_timestamp,
            to=to_timestamp,
            interval=timeframe
        )

        # éªŒè¯è¿”å›çš„æ•°æ®ç‚¹æ•°é‡
        if len(api_response) < required_points:
            logger.error("Insufficient data points for %s. Required: %d, Returned: %d", timeframe, required_points, len(api_response))
            return None

        # æ‰“å°è°ƒè¯•ä¿¡æ¯
        logger.debug("Fetched %d data points for timeframe %s.", len(api_response), timeframe)

        return api_response
    except ApiException as e:
        logger.error("Exception when calling list_futures_candlesticks: %s", e)
        return None

# åœ¨ parse_market_data å‡½æ•°ä¸­æ·»åŠ å¯¹åŸå§‹æ•°æ®çš„è¯¦ç»†è°ƒè¯•ä¿¡æ¯

def parse_market_data(api_response):
    """
    è§£æ API è¿”å›çš„å¸‚åœºæ•°æ®ä¸º DataFrameã€‚
    :param api_response: API è¿”å›çš„å¸‚åœºæ•°æ®
    :return: è§£æåçš„ DataFrame
    """
    try:
        logger.debug("Raw API response (first 5 items): %s", api_response[:5])
        logger.debug("Total items in API response: %d", len(api_response))

        data = []
        for item in api_response:
            if isinstance(item, dict):
                data.append({
                    "timestamp": float(item.get("t", 0)),
                    "low": float(item.get("l", 0)),
                    "high": float(item.get("h", 0)),
                    "last": float(item.get("c", 0)),
                    "vol": float(item.get("v", 0))
                })
            else:
                data.append({
                    "timestamp": float(getattr(item, "t", 0)),
                    "low": float(getattr(item, "l", 0)),
                    "high": float(getattr(item, "h", 0)),
                    "last": float(getattr(item, "c", 0)),
                    "vol": float(getattr(item, "v", 0))
                })
        df = pd.DataFrame(data)
        logger.debug("Parsed DataFrame row count: %d", len(df))
        logger.debug("Parsed DataFrame (first 5 rows):\n%s", df.head())
        return df
    except Exception as e:
        logger.error("Error parsing market data: %s", e)
        return pd.DataFrame()

# Replace talib.EMA with pandas' rolling mean for EMA calculation
def calculate_ema(series, timeperiod):
    return series.ewm(span=timeperiod, adjust=False).mean()

# Replace talib.MACD with manual calculation
def calculate_macd(series, fastperiod=12, slowperiod=26, signalperiod=9):
    ema_fast = calculate_ema(series, fastperiod)
    ema_slow = calculate_ema(series, slowperiod)
    macd = ema_fast - ema_slow
    signal = macd.ewm(span=signalperiod, adjust=False).mean()
    hist = macd - signal
    return macd, signal, hist

# Replace talib.RSI with manual calculation
def calculate_rsi(series, timeperiod=14):
    delta = series.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=timeperiod).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=timeperiod).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

# Replace talib.ATR with manual calculation
def calculate_atr(high, low, close, timeperiod=14):
    tr1 = high - low
    tr2 = (high - close.shift()).abs()
    tr3 = (low - close.shift()).abs()
    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    atr = tr.rolling(window=timeperiod).mean()
    return atr

# åœ¨ calculate_indicators å‡½æ•°ä¸­æ·»åŠ æ›´å¤šè°ƒè¯•ä¿¡æ¯

def calculate_indicators(data):
    df = pd.DataFrame(data)
    logger.debug("è¾“å…¥æ•°æ®æ¡†è¡Œæ•°ï¼š%d", len(df))  # æ‰“å°æ•°æ®æ¡†è¡Œæ•°
    logger.debug("è¾“å…¥æ•°æ®æ¡†å†…å®¹ï¼ˆå‰å‡ è¡Œï¼‰ï¼š\n%s", df.head())  # æ‰“å°æ•°æ®æ¡†å†…å®¹

    # éªŒè¯æ•°æ®ç‚¹æ•°é‡
    if len(df) < 14:
        logger.error("Insufficient data points for indicator calculations. Required: 14, Available: %d", len(df))
        return pd.DataFrame()

    # å°†å„åˆ—æ•°æ®ç±»å‹è½¬æ¢ä¸ºfloatä»¥ä¾¿è¿›è¡Œè®¡ç®—
    df['last'] = df['last'].astype(float)
    df['high'] = df['high'].astype(float)
    df['low'] = df['low'].astype(float)
    df['vol'] = df['vol'].astype(float)

    # è®¡ç®—EMA
    df['EMA21'] = calculate_ema(df['last'], timeperiod=21)
    df['EMA34'] = calculate_ema(df['last'], timeperiod=34)
    df['EMA144'] = calculate_ema(df['last'], timeperiod=144)
    df['EMA169'] = calculate_ema(df['last'], timeperiod=169)

    # è®¡ç®—MACD
    df['macd'], df['signal'], df['hist'] = calculate_macd(df['last'])

    # è®¡ç®—RSI
    df['RSI'] = calculate_rsi(df['last'])

    return df

# è®¡ç®—æ‰“åˆ†
def candle_pattern_score(df):
    # åªçœ‹æœ€åä¸¤æ ¹æˆ–ä¸‰æ ¹Kçº¿
    if len(df) < 3:
        return 0, "æ— å½¢æ€"
    # å–æœ€åä¸‰æ ¹Kçº¿çš„å¼€æ”¶
    close1, close2, close3 = df['last'].iloc[-3], df['last'].iloc[-2], df['last'].iloc[-1]
    open1, open2, open3 = close1, close2, close3  # è‹¥æœ‰openåˆ—å¯æ›¿æ¢
    high1, high2, high3 = df['high'].iloc[-3], df['high'].iloc[-2], df['high'].iloc[-1]
    low1, low2, low3 = df['low'].iloc[-3], df['low'].iloc[-2], df['low'].iloc[-1]
    # é˜³åé˜´
    if close3 > open3 and close2 < open2 and close3 > open2 and open3 < close2:
        return 2, "é˜³åé˜´"
    # é˜´åé˜³
    if close3 < open3 and close2 > open2 and close3 < open2 and open3 > close2:
        return 2, "é˜´åé˜³"
    # é”¤å­çº¿
    if close3 > open3 and (open3 - low3) > 2 * abs(close3 - open3) and (high3 - close3) < abs(close3 - open3):
        return 2, "é”¤å­çº¿"
    # ä¸ŠåŠçº¿
    if close3 < open3 and (open3 - low3) > 2 * abs(close3 - open3) and (high3 - open3) < abs(close3 - open3):
        return 2, "ä¸ŠåŠçº¿"
    # åå­—æ˜Ÿ
    if abs(close3 - open3) < (high3 - low3) * 0.1:
        return 2, "åå­—æ˜Ÿ"
    # æ—©æ™¨ä¹‹æ˜Ÿ
    if close1 < open1 and abs(close2 - open2) < (high2 - low2) * 0.2 and close3 > open3 and close3 > (open1 + close1) / 2:
        return 2, "æ—©æ™¨ä¹‹æ˜Ÿ"
    # é»„æ˜ä¹‹æ˜Ÿ
    if close1 > open1 and abs(close2 - open2) < (high2 - low2) * 0.2 and close3 < open3 and close3 < (open1 + close1) / 2:
        return 2, "é»„æ˜ä¹‹æ˜Ÿ"
    # ä¹Œäº‘ç›–é¡¶
    if close2 > open2 and close3 < open3 and open3 > close2 and close3 < (open2 + close2) / 2:
        return 2, "ä¹Œäº‘ç›–é¡¶"
    # åˆºé€å½¢æ€
    if close2 < open2 and close3 > open3 and open3 < close2 and close3 > (open2 + close2) / 2:
        return 2, "åˆºé€å½¢æ€"
    # ä¸‰è¿é˜³
    if close1 < close2 < close3 and close1 > open1 and close2 > open2 and close3 > open3:
        return 2, "ä¸‰è¿é˜³"
    # ä¸‰è¿é˜´
    if close1 > close2 > close3 and close1 < open1 and close2 < open2 and close3 < open3:
        return 2, "ä¸‰è¿é˜´"
    return 0, "æ— å½¢æ€"

def rsi_signal(df):
    """
    ç»¼åˆåˆ¤æ–­RSIå½¢æ€å˜åŒ–å’Œæ•°å€¼ï¼š
    - ä¸Šå‹¾ï¼šå‰ä¸€æ ¹RSIå°äºå½“å‰RSIï¼Œä¸”å½“å‰RSI>50
    - ä¸‹å¼¯ï¼šå‰ä¸€æ ¹RSIå¤§äºå½“å‰RSIï¼Œä¸”å½“å‰RSI<50
    - è¶…ä¹°ï¼šå½“å‰RSI>70
    - è¶…å–ï¼šå½“å‰RSI<30
    è¿”å›ï¼š('ä¸Šå‹¾'/'ä¸‹å¼¯'/'è¶…ä¹°'/'è¶…å–'/'å¼ºåŠ¿'/'å¼±åŠ¿')
    """
    if 'RSI' not in df.columns or len(df) < 2:
        return 'æ— ä¿¡å·'
    prev_rsi = df['RSI'].iloc[-2]
    curr_rsi = df['RSI'].iloc[-1]
    if curr_rsi > 70:
        return 'è¶…ä¹°'
    if curr_rsi < 30:
        return 'è¶…å–'
    if curr_rsi > prev_rsi and curr_rsi > 50:
        return 'ä¸Šå‹¾'
    if curr_rsi < prev_rsi and curr_rsi < 50:
        return 'ä¸‹å¼¯'
    if curr_rsi > 50:
        return 'å¼ºåŠ¿'
    if curr_rsi < 50:
        return 'å¼±åŠ¿'
    return 'æ— ä¿¡å·'

# åœ¨calculate_scoresä¸­é›†æˆRSIå½¢æ€åˆ¤æ–­

def calculate_scores(df, trend_score):
    """
    ç»Ÿä¸€é‡‡ç”¨å°åˆ†åˆ¶ï¼ˆæ¯é¡¹2åˆ†ï¼Œæ»¡åˆ†10åˆ†ï¼Œ7åˆ†åŠä»¥ä¸Šä¸ºå¼ºä¿¡å·ï¼‰ï¼Œä¸READMEä¸€è‡´ã€‚
    1Hè¶‹åŠ¿ã€MACDã€RSIã€Kçº¿å½¢æ€ã€åŠ¨é‡èƒŒç¦»å„å 2åˆ†ã€‚
    7åˆ†åŠä»¥ä¸Šä¸ºå¼ºä¿¡å·ã€‚
    EMA21è¿‡æ»¤ï¼š15mæ”¶ç›˜ä»·éœ€åœ¨EMA21ä¸Šæ–¹ï¼ˆå¤šå¤´ï¼‰æˆ–ä¸‹æ–¹ï¼ˆç©ºå¤´ï¼‰æ‰å…è®¸åŠ åˆ†ï¼Œå¦åˆ™ç›´æ¥è¿”å›0åˆ†ã€‚
    æ˜ç»†åˆ†æ•°å’Œå„é¡¹åŸå§‹ä¿¡å·å‡å®Œæ•´è¾“å‡ºã€‚
    """
    required_cols = ['RSI', 'EMA144', 'EMA169', 'macd', 'signal', 'last', 'EMA21']
    for col in required_cols:
        if col not in df.columns:
            logger.error("'%s' column missing in DataFrame. Please check indicator calculation.", col)
            return 0, 0, {}
    longScore = 0
    shortScore = 0
    details = {}
    sub_scores = {}
    # 1Hè¶‹åŠ¿åˆ†æ•°
    if trend_score == 2:
        longScore += 2
        sub_scores['1h_trend'] = {'long': 2, 'short': 0, 'desc': 'ä¸Šæ¶¨'}
        details['1h_trend'] = 'ä¸Šæ¶¨'
    elif trend_score == -2:
        shortScore += 2
        sub_scores['1h_trend'] = {'long': 0, 'short': 2, 'desc': 'ä¸‹è·Œ'}
        details['1h_trend'] = 'ä¸‹è·Œ'
    else:
        sub_scores['1h_trend'] = {'long': 0, 'short': 0, 'desc': 'éœ‡è¡'}
        details['1h_trend'] = 'éœ‡è¡'
    # MACD
    if df['macd'].iloc[-1] > df['signal'].iloc[-1]:
        longScore += 2
        sub_scores['macd'] = {'long': 2, 'short': 0, 'desc': 'é‡‘å‰'}
        details['macd'] = 'é‡‘å‰'
    else:
        shortScore += 2
        sub_scores['macd'] = {'long': 0, 'short': 2, 'desc': 'æ­»å‰'}
        details['macd'] = 'æ­»å‰'
    # RSIå½¢æ€
    rsi_shape = rsi_signal(df)
    details['rsi'] = rsi_shape
    if rsi_shape in ['ä¸Šå‹¾', 'è¶…ä¹°', 'å¼ºåŠ¿']:
        longScore += 2
        sub_scores['rsi'] = {'long': 2, 'short': 0, 'desc': rsi_shape}
    elif rsi_shape in ['ä¸‹å¼¯', 'è¶…å–', 'å¼±åŠ¿']:
        shortScore += 2
        sub_scores['rsi'] = {'long': 0, 'short': 2, 'desc': rsi_shape}
    else:
        sub_scores['rsi'] = {'long': 0, 'short': 0, 'desc': rsi_shape}
    # Kçº¿å½¢æ€
    candle_score, candle_type = candle_pattern_score(df)
    details['candle'] = candle_type
    if candle_type in ['é˜³åé˜´', 'é”¤å­çº¿', 'æ—©æ™¨ä¹‹æ˜Ÿ', 'åˆºé€å½¢æ€', 'ä¸‰è¿é˜³']:
        longScore += 2
        sub_scores['candle'] = {'long': 2, 'short': 0, 'desc': candle_type}
    elif candle_type in ['é˜´åé˜³', 'ä¸ŠåŠçº¿', 'é»„æ˜ä¹‹æ˜Ÿ', 'ä¹Œäº‘ç›–é¡¶', 'ä¸‰è¿é˜´']:
        shortScore += 2
        sub_scores['candle'] = {'long': 0, 'short': 2, 'desc': candle_type}
    else:
        sub_scores['candle'] = {'long': 0, 'short': 0, 'desc': candle_type}
    # åŠ¨é‡èƒŒç¦»
    momentum = detect_momentum_divergence(df)
    if momentum > 0:
        longScore += 2
        sub_scores['momentum_divergence'] = {'long': 2, 'short': 0, 'desc': 'çœ‹å¤šèƒŒç¦»'}
        details['momentum_divergence'] = 'çœ‹å¤šèƒŒç¦»'
    elif momentum < 0:
        shortScore += 2
        sub_scores['momentum_divergence'] = {'long': 0, 'short': 2, 'desc': 'çœ‹ç©ºèƒŒç¦»'}
        details['momentum_divergence'] = 'çœ‹ç©ºèƒŒç¦»'
    else:
        sub_scores['momentum_divergence'] = {'long': 0, 'short': 0, 'desc': 'æ— èƒŒç¦»'}
        details['momentum_divergence'] = 'æ— èƒŒç¦»'
    # EMA21è¿‡æ»¤ï¼ˆæœ€åæ‰§è¡Œï¼Œä¿ç•™æ˜ç»†ï¼‰
    last = df['last'].iloc[-1]
    ema21 = df['EMA21'].iloc[-1]
    if last < ema21:
        details['ema21_filter'] = '15mæ”¶ç›˜ä»·æœªç«™ä¸ŠEMA21ï¼Œlongä¿¡å·æ— æ•ˆ'
        sub_scores['ema21_filter'] = {'long': 0, 'short': 0, 'desc': 'longä¿¡å·è¢«è¿‡æ»¤'}
        details['sub_scores'] = sub_scores
        return 0, shortScore, details
    if last > ema21:
        details['ema21_filter'] = '15mæ”¶ç›˜ä»·æœªè·Œç ´EMA21ï¼Œshortä¿¡å·æ— æ•ˆ'
        sub_scores['ema21_filter'] = {'long': 0, 'short': 0, 'desc': 'shortä¿¡å·è¢«è¿‡æ»¤'}
        details['sub_scores'] = sub_scores
        return longScore, 0, details
    details['sub_scores'] = sub_scores
    return longScore, shortScore, details

# åŠ¨é‡èƒŒç¦»æ£€æµ‹æ¨¡å—
def detect_momentum_divergence(df):
    # æ£€æŸ¥å…³é”®åˆ—æ˜¯å¦å­˜åœ¨
    if 'macd' not in df.columns or 'last' not in df.columns:
        logger.error("'macd' or 'last' column missing in DataFrame. Please check indicator calculation.")
        return 0  # ç¼ºå¤±å…³é”®æŒ‡æ ‡ï¼Œæ— æ³•æ£€æµ‹
    if len(df) < 2:
        return 0  # æ•°æ®ä¸è¶³ï¼Œæ— æ³•æ£€æµ‹
    price_diff = df['last'].iloc[-1] - df['last'].iloc[-2]
    macd_diff = df['macd'].iloc[-1] - df['macd'].iloc[-2]
    if price_diff > 0 and macd_diff < 0:
        logger.debug("æ£€æµ‹åˆ°çœ‹ç©ºèƒŒç¦»ï¼Œé™„åŠ ç©ºå•å¾—åˆ† +2")
        return -2  # çœ‹ç©ºèƒŒç¦»
    elif price_diff < 0 and macd_diff > 0:
        logger.debug("æ£€æµ‹åˆ°çœ‹å¤šèƒŒç¦»ï¼Œé™„åŠ å¤šå•å¾—åˆ† +2")
        return 2  # çœ‹å¤šèƒŒç¦»
    return 0

# è®¡ç®—æ­¢æŸã€æ­¢ç›ˆå’Œé£æŠ¥æ¯”
def calculate_sl_tp(df, risk_factor=1):
    atr = calculate_atr(df['high'], df['low'], df['last']).iloc[-1]
    stopLossLong = df['last'].iloc[-1] - atr * risk_factor
    stopLossShort = df['last'].iloc[-1] + atr * risk_factor
    
    tp1Long = df['last'].iloc[-1] + atr * 2 * risk_factor
    tp2Long = df['last'].iloc[-1] + atr * 3 * risk_factor
    
    tp1Short = df['last'].iloc[-1] - atr * 2 * risk_factor
    tp2Short = df['last'].iloc[-1] - atr * 3 * risk_factor
    
    rrLong = (tp1Long - df['last'].iloc[-1]) / (df['last'].iloc[-1] - stopLossLong)
    rrShort = (df['last'].iloc[-1] - tp1Short) / (stopLossShort - df['last'].iloc[-1])
    
    return stopLossLong, stopLossShort, tp1Long, tp2Long, tp1Short, tp2Short, rrLong, rrShort

# åŠ¨æ€æ»šåŠ¨æ­¢ç›ˆæ­¢æŸå»ºè®®
def suggest_trailing_sl_tp(current_price, atr, risk_factor=1):
    trailing_sl = current_price - atr * risk_factor  # æ»šåŠ¨æ­¢æŸ
    trailing_tp = current_price + atr * risk_factor * 2  # æ»šåŠ¨æ­¢ç›ˆ
    return trailing_sl, trailing_tp

# å¸‚åœºçŠ¶æ€æ£€æµ‹æ¨¡å—
def detect_market_state(df):
    # è®¡ç®—ATR
    atr = calculate_atr(df['high'], df['low'], df['last'])
    atr_mean = atr.tail(30).mean()  # è¿‘30æ ¹Kçº¿ATRå‡å€¼
    curr_atr = atr.iloc[-1]
    # é˜ˆå€¼è®¾ä¸ºå‡å€¼çš„1.2å€
    atr_threshold = 1.2 * atr_mean
    # æ—¥å¿—è¾“å‡º
    logger.debug(f"ATRå‡å€¼(30): {atr_mean:.4f}, å½“å‰ATR: {curr_atr:.4f}, é˜ˆå€¼: {atr_threshold:.4f}")
    # åˆ¤æ–­å¸‚åœºçŠ¶æ€
    if curr_atr > atr_threshold:
        return "trend"  # é«˜æ³¢åŠ¨è¶‹åŠ¿å¸‚
    else:
        return "range"  # ä½æ³¢åŠ¨éœ‡è¡å¸‚

# æ›´æ–° Vegas éš§é“åˆ¤æ–­é€»è¾‘ï¼Œå¢åŠ åŒºé—´æ‰©å¼ å’Œæ”¶çª„è¶‹åŠ¿åˆ¤æ–­

def analyze_vegas_tunnel(df):
    required_cols = ['EMA144', 'EMA169', 'last']
    for col in required_cols:
        if col not in df.columns:
            logger.error("'%s' column missing in DataFrame. Please check indicator calculation.", col)
            return "insufficient_data", "insufficient_data", 0
    if len(df) < 100:
        logger.error("Insufficient data points for Vegas Tunnel analysis.")
        return "insufficient_data", "insufficient_data", 0
    ema_diff = df['EMA144'] - df['EMA169']
    ema144_slope = df['EMA144'].diff().mean()
    ema169_slope = df['EMA169'].diff().mean()
    price = df['last'].iloc[-1]
    ema144 = df['EMA144'].iloc[-1]
    ema169 = df['EMA169'].iloc[-1]
    # æ‰“å°è°ƒè¯•ä¿¡æ¯
    if logger.isEnabledFor(logging.DEBUG):
        logger.debug(f"Vegas Tunnelåˆ¤æ–­å‚æ•°: price={price}, ema144={ema144}, ema169={ema169}, ema144_slope={ema144_slope}, ema169_slope={ema169_slope}, ema_diff_now={ema_diff.iloc[-1]}, ema_diff_20ago={ema_diff.iloc[-20]}")
    # è¶‹åŠ¿åˆ†æ•°
    trend_score = 0
    if ema144_slope > 0 and ema169_slope > 0 and (price > ema144 and price > ema169) and (ema_diff.iloc[-1] > ema_diff.iloc[-20]):
        trend = "uptrend"
        trend_score = 2
    elif ema144_slope < 0 and ema169_slope < 0 and (price < ema144 and price < ema169) and (ema_diff.iloc[-1] > ema_diff.iloc[-20]):
        trend = "downtrend"
        trend_score = -2
    elif abs(ema_diff.iloc[-1]) < 2 or (abs(ema144_slope) < 0.1 and abs(ema169_slope) < 0.1):
        trend = "sideways"
        trend_score = 0
    else:
        trend = "cross"
        trend_score = 0
    ema_diff_slope = ema_diff.diff().mean()
    if logger.isEnabledFor(logging.DEBUG):
        logger.debug(f"Vegas TunnelåŒºé—´å˜åŒ–: ema_diff_slope={ema_diff_slope}")
    if ema_diff_slope > 0:
        range_change = "expanding"
    elif ema_diff_slope < 0:
        range_change = "contracting"
    else:
        range_change = "stable"
    return trend, range_change, trend_score

# æ›´æ–°æ•°æ®éªŒè¯å’Œé”™è¯¯å¤„ç†é€»è¾‘
def validate_data(df, required_points):
    """
    éªŒè¯æ•°æ®ç‚¹æ˜¯å¦è¶³å¤Ÿã€‚
    :param df: æ•°æ®æ¡†
    :param required_points: æ‰€éœ€çš„æœ€å°æ•°æ®ç‚¹æ•°é‡
    :return: å¦‚æœæ•°æ®è¶³å¤Ÿè¿”å› Trueï¼Œå¦åˆ™è¿”å› False
    """
    if len(df) < required_points:
        logger.error("Insufficient data points. Required: %d, Available: %d", required_points, len(df))
        return False
    return True

# å¤šå‘¨æœŸMACDå½¢æ€åˆ¤æ–­

def macd_cross_signal(df):
    """
    åˆ¤æ–­MACDé‡‘å‰/æ­»å‰å½¢æ€ï¼š
    - åˆšåˆšé‡‘å‰ï¼šå‰ä¸€æ ¹æ­»å‰ï¼Œè¿™ä¸€æ ¹é‡‘å‰
    - åˆšåˆšæ­»å‰ï¼šå‰ä¸€æ ¹é‡‘å‰ï¼Œè¿™ä¸€æ ¹æ­»å‰
    - æŒç»­é‡‘å‰/æ­»å‰
    è¿”å›ï¼š'just_golden', 'just_dead', 'golden', 'dead', 'none'
    """
    if 'macd' not in df.columns or 'signal' not in df.columns or len(df) < 2:
        return 'none'
    prev_macd, prev_signal = df['macd'].iloc[-2], df['signal'].iloc[-2]
    curr_macd, curr_signal = df['macd'].iloc[-1], df['signal'].iloc[-1]
    if prev_macd <= prev_signal and curr_macd > curr_signal:
        return 'just_golden'  # åˆšåˆšé‡‘å‰
    elif prev_macd >= prev_signal and curr_macd < curr_signal:
        return 'just_dead'    # åˆšåˆšæ­»å‰
    elif curr_macd > curr_signal:
        return 'golden'      # æŒç»­é‡‘å‰
    elif curr_macd < curr_signal:
        return 'dead'        # æŒç»­æ­»å‰
    else:
        return 'none'

# 5åˆ†é’Ÿå‘¨æœŸä¿¡å·ç¡®è®¤ã€‚direction: 'long' or 'short'
def confirm_5m_signal(df_5min, direction):
    """
    5åˆ†é’Ÿå‘¨æœŸä¿¡å·ç¡®è®¤ã€‚direction: 'long' or 'short'
    ä»¥5mæœ€åä¸€æ ¹Kçº¿çš„macdä¸signalåˆ¤æ–­æ–¹å‘ã€‚
    """
    if len(df_5min) < 2:
        return False
    if 'macd' not in df_5min.columns or 'signal' not in df_5min.columns:
        return False
    if direction == 'long' and df_5min['macd'].iloc[-1] > df_5min['signal'].iloc[-1]:
        return True
    if direction == 'short' and df_5min['macd'].iloc[-1] < df_5min['signal'].iloc[-1]:
        return True
    return False

# ä¸»å‡½æ•°
def main():
    # è·å–5åˆ†é’ŸKçº¿æ•°æ®
    market_data_5min = get_market_data(timeframe='5m')
    if market_data_5min is None:
        return
    if not market_data_5min:
        logger.error("No data returned for 5-minute candlesticks. Please check the API parameters or data availability.")
        return
    
    # è·å–1å°æ—¶Kçº¿æ•°æ®
    market_data_hour = get_market_data(timeframe='1h')
    if market_data_hour is None:
        return
    
    # è·å–15åˆ†é’ŸKçº¿æ•°æ®
    market_data_15min = get_market_data(timeframe='15m')
    if market_data_15min is None:
        return
    
    # è§£æå…¨éƒ¨Kçº¿æ•°æ®
    df_5min = parse_market_data(market_data_5min)
    df_hour = parse_market_data(market_data_hour)
    df_15min = parse_market_data(market_data_15min)

    # è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
    df_5min = calculate_indicators(df_5min)
    df_hour = calculate_indicators(df_hour)
    df_15min = calculate_indicators(df_15min)

    # åœ¨ä¸»å‡½æ•°ä¸­æ·»åŠ æ•°æ®éªŒè¯
    if not validate_data(df_5min, 14):
        logger.error("5åˆ†é’Ÿæ•°æ®ä¸è¶³ï¼Œæ— æ³•è®¡ç®—æŒ‡æ ‡ã€‚")
        return

    if not validate_data(df_hour, 100):
        logger.error("1å°æ—¶æ•°æ®ä¸è¶³ï¼Œæ— æ³•è¿›è¡Œ Vegas éš§é“åˆ†æã€‚")
        return

    if not validate_data(df_15min, 14):
        logger.error("15åˆ†é’Ÿæ•°æ®ä¸è¶³ï¼Œæ— æ³•è®¡ç®—æŒ‡æ ‡ã€‚")
        return
    
    # æ‰“åˆ†ï¼ˆåŸºäº5åˆ†é’ŸKçº¿ã€1å°æ—¶å’Œ15åˆ†é’ŸKçº¿ï¼‰
    trend_direction, range_change, trend_score = analyze_vegas_tunnel(df_hour)
    longScore, shortScore, signal_details = calculate_scores(df_15min, trend_score)

    # 5mç¡®è®¤
    long_5m = confirm_5m_signal(df_5min, 'long')
    short_5m = confirm_5m_signal(df_5min, 'short')

    # è¾“å‡ºæ‰“åˆ†å’Œå¼€ä»“å»ºè®®ï¼ˆæ ¼å¼åŒ–è¾“å‡ºï¼Œä¾¿äºå¸‚åœºæ“ä½œå‚è€ƒï¼‰
    output = {
        "time": pd.to_datetime(df_15min['timestamp'].iloc[-1], unit='s').strftime('%Y-%m-%d %H:%M'),
        "price": float(df_15min['last'].iloc[-1]),
        "long_score": int(longScore),
        "short_score": int(shortScore),
        "recommendation": "",
        "take_profit": None,
        "stop_loss": None,
        "signal_details": signal_details
    }
    # æ­¢ç›ˆæ­¢æŸ
    stopLossLong, stopLossShort, tp1Long, tp2Long, tp1Short, tp2Short, rrLong, rrShort = calculate_sl_tp(df_5min)
    # æ¨èå»ºè®®
    if longScore >= 7 and long_5m:
        output["recommendation"] = "å¤šå¤´å¼ºåŠ¿ï¼Œå»ºè®®å¼€å¤šå•"
        output["take_profit"] = float(tp1Long)
        output["stop_loss"] = float(stopLossLong)
    elif shortScore >= 7 and short_5m:
        output["recommendation"] = "ç©ºå¤´å¼ºåŠ¿ï¼Œå»ºè®®å¼€ç©ºå•"
        output["take_profit"] = float(tp1Short)
        output["stop_loss"] = float(stopLossShort)
    else:
        output["recommendation"] = "æ— æ˜ç¡®ä¿¡å·ï¼Œè§‚æœ›ä¸ºä¸»"
    # åœ¨ä¸»å‡½æ•°ä¸­åˆ†åˆ«åˆ¤æ–­1hã€15mã€5mçš„MACDå½¢æ€ï¼Œå¹¶ç»¼åˆå†³ç­–
    macd_1h = macd_cross_signal(df_hour)
    macd_15m = macd_cross_signal(df_15min)
    macd_5m = macd_cross_signal(df_5min)
    macd_multi = {
        '1h': macd_1h,
        '15m': macd_15m,
        '5m': macd_5m
    }
    output['macd_multi_signal'] = macd_multi
    # å¤šå‘¨æœŸå…±æŒ¯å†³ç­–
    if macd_1h in ['just_golden', 'golden'] and macd_15m in ['just_golden', 'golden'] and macd_5m in ['just_golden', 'golden']:
        output['multi_timeframe_macd'] = 'ä¸‰å‘¨æœŸé‡‘å‰å…±æŒ¯ï¼Œå¼ºå¤šä¿¡å·'
    elif macd_1h in ['just_dead', 'dead'] and macd_15m in ['just_dead', 'dead'] and macd_5m in ['just_dead', 'dead']:
        output['multi_timeframe_macd'] = 'ä¸‰å‘¨æœŸæ­»å‰å…±æŒ¯ï¼Œå¼ºç©ºä¿¡å·'
    else:
        output['multi_timeframe_macd'] = 'å¤šå‘¨æœŸä¿¡å·ä¸ä¸€è‡´ï¼Œè§‚æœ›ä¸ºä¸»'

    # ===== å¢å¼ºå¯è¯»æ€§è¾“å‡º =====
    logger.info("\n===== ç­–ç•¥ä¿¡å·ç»“æ„åŒ–è¾“å‡ºï¼ˆå°åˆ†åˆ¶ï¼Œæ»¡åˆ†10åˆ†ï¼Œ7åˆ†åŠä»¥ä¸Šä¸ºå¼ºä¿¡å·ï¼‰ =====")
    logger.info("æ—¶é—´: %s", output['time'])
    logger.info("æœ€æ–°ä»·æ ¼: %.2f", output['price'])
    logger.info("1Hè¶‹åŠ¿: %s | åŒºé—´: %s", trend_direction, range_change)
    logger.info("15m Long Score: %d | Short Score: %d", output['long_score'], output['short_score'])
    logger.info("MACDå½¢æ€: 1H=%s, 15m=%s, 5m=%s", macd_1h, macd_15m, macd_5m)
    logger.info("å¤šå‘¨æœŸMACDå…±æŒ¯: %s", output['multi_timeframe_macd'])
    
    if output['recommendation'] == "å¤šå¤´å¼ºåŠ¿ï¼Œå»ºè®®å¼€å¤šå•":
        logger.info("ã€å»ºè®®å¼€å¤šå•ã€‘ å¼€ä»“ä»·: %.2f æ­¢æŸ: %.2f æ­¢ç›ˆ: %.2f", output['price'], output['stop_loss'], output['take_profit'])
    elif output['recommendation'] == "ç©ºå¤´å¼ºåŠ¿ï¼Œå»ºè®®å¼€ç©ºå•":
        logger.info("ã€å»ºè®®å¼€ç©ºå•ã€‘ å¼€ä»“ä»·: %.2f æ­¢æŸ: %.2f æ­¢ç›ˆ: %.2f", output['price'], output['stop_loss'], output['take_profit'])
    else:
        logger.info("ã€å»ºè®®ã€‘%s", output['recommendation'])
    logger.info("===== END =====\n")
    # æ•´ç†ä¿¡å·ç»†èŠ‚è¾“å‡º
    details = output['signal_details']
    sub_scores = details.get('sub_scores', {})
    logger.info("------ ä¿¡å·ç»†èŠ‚æ˜ç»† ------")
    for k, v in sub_scores.items():
        logger.info("%s: longå¾—åˆ†=%s, shortå¾—åˆ†=%s, è¯´æ˜=%s", k, v.get('long', 0), v.get('short', 0), v.get('desc', ''))
    logger.info("-------------------------")
    # Telegramæ¨é€ï¼ˆä»…å½“å¤šæˆ–ç©ºåˆ†å€¼>=6æ—¶å‘é€ï¼‰
    if output['long_score'] >= 7 or output['short_score'] >= 7:
        # æ—¶é—´è°ƒæ•´ä¸ºGMT+8
        from datetime import datetime, timedelta
        gmt8_time = (datetime.strptime(output['time'], '%Y-%m-%d %H:%M') + timedelta(hours=8)).strftime('%Y-%m-%d %H:%M')
        tg_msg = (
            f"ã€ETH Vegas Tunnel ç­–ç•¥ä¿¡å·ã€‘\n"
            f"æ—¶é—´ï¼š{gmt8_time} (GMT+8)\n"
            f"æœ€æ–°ä»·ï¼š{output['price']}\n"
            f"1Hè¶‹åŠ¿ï¼š{trend_direction} | åŒºé—´ï¼š{range_change}\n"
            f"å¤šå¤´åˆ†ï¼š{output['long_score']} | ç©ºå¤´åˆ†ï¼š{output['short_score']}\n"
            f"MACDå½¢æ€ï¼š1H={macd_1h}ï¼Œ15m={macd_15m}ï¼Œ5m={macd_5m}\n"
            f"å¤šå‘¨æœŸå…±æŒ¯ï¼š{output['multi_timeframe_macd']}\n"
            f"å»ºè®®ï¼š{output['recommendation']}\n"
            f"==================\n"
            f"â–¶ï¸ å¼€ä»“ä»·ï¼š{output['price']}\n"
            f"ğŸ¯ æ­¢ç›ˆ1ï¼ˆTP1ï¼‰ï¼š{output.get('take_profit', '')}\n"
            f"ğŸ¯ æ­¢ç›ˆ2ï¼ˆTP2ï¼‰ï¼š{output.get('take_profit2', '')}\n"
            f"â›” æ­¢æŸï¼ˆSLï¼‰ï¼š{output.get('stop_loss', '')}\n"
            f"==================\n"
            f"æ“ä½œå»ºè®®ï¼š\n"
            f" - éœ‡è¡å¸‚ä¼˜å…ˆTP1ï¼Œè¶‹åŠ¿å¸‚å¯åˆ†æ‰¹æŒæœ‰è‡³TP2\n"
            f" - è¯·ç»“åˆè‡ªèº«é£æ§ç†æ€§æ“ä½œ"
        )
        send_telegram_message(tg_msg)
    else:
        logger.debug("åˆ†å€¼æœªè¾¾åˆ°æ¨é€é˜ˆå€¼ï¼ˆlong_score=%d, short_score=%dï¼‰ï¼Œä¸å‘é€Telegramæ¶ˆæ¯ã€‚", output['long_score'], output['short_score'])

TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")

def send_telegram_message(text):
    if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
        logger.warning("æœªé…ç½®TELEGRAM_BOT_TOKENæˆ–TELEGRAM_CHAT_IDï¼Œæ— æ³•å‘é€Telegramé€šçŸ¥ã€‚")
        return
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {"chat_id": TELEGRAM_CHAT_ID, "text": text, "parse_mode": "Markdown"}
    logger.debug(f"å‡†å¤‡å‘é€Telegramé€šçŸ¥: url={url}, chat_id={TELEGRAM_CHAT_ID}, text={text}")
    try:
        resp = requests.post(url, data=payload, timeout=10)
        logger.debug(f"Telegramå“åº”: status_code={resp.status_code}, text={resp.text}")
        if resp.status_code == 200:
            logger.info("å·²å‘é€Telegramé€šçŸ¥ã€‚")
        else:
            logger.warning(f"Telegramé€šçŸ¥å¤±è´¥: {resp.text}")
    except Exception as e:
        logger.warning(f"Telegramé€šçŸ¥å¼‚å¸¸: {e}")

if __name__ == "__main__":
    main()
